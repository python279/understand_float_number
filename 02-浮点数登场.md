# 2 浮点数登场

在理解了整数的精确性和可靠性之后，我们现在要面对一个更复杂的世界：浮点数。浮点数打破了整数的"规则"，引入了新的挑战和可能性。

## 2.1 IEEE 754 定义的浮点数

### 2.1.1 基本公式

IEEE 754标准定义的浮点数表示公式：

$$
value = (-1)^s \times (1 + Σ frac[i]·2^{-(i+1)}) \times 2^{(exp - bias)}
$$

其中：
- **s**: 符号位 (0=正数, 1=负数)
- **frac[i]**: 尾数位的第i位
- **exp**: 指数位的值
- **bias**: 指数偏移量

### 2.1.2 各种精度格式对比

**Table 10.3 Extended IEEE 754 Format Parameters**

| Parameter | fp8e5m2 | fp8e4m3 | float16 | bfloat16 | Binary32 | Binary64 | Binary128 |
|---|---|---|---|---|---|---|---|
| Storage width (bits)（存储宽度，位数） | 8 | 8 | 16 | 16 | 32 | 64 | 128 |
| Exponent width (bits)（指数宽度，位数） | 5 | 4 | 5 | 8 | 8 | 11 | 15 |
| Exponent bias（指数偏移量） | 15 | 7 | 15 | 127 | 127 | 1023 | 16383 |
| Maximum exponent（最大指数） | 15 | 7 | 15 | 127 | 127 | 1023 | 16383 |
| Minimum exponent（最小指数） | -14 | -6 | -14 | -126 | -126 | -1022 | -16382 |
| Approx normal number range (base 10)（近似正规数范围（以10为底）） | ~10^-4.5 – 10^4.5 | ~10^-2.4 – 10^2.4 | ~10^-4.8 – 10^4.8 | ~10^-38 – 10^38 | 10^-38 – 10^+38 | 10^-308 – 10^+308 | 10^-4932 – 10^+4932 |
| Trailing significand width (bits)*（尾数部分宽度，位数）* | 2 | 3 | 10 | 7 | 23 | 52 | 112 |
| Number of exponents（指数数量） | 30 | 14 | 30 | 254 | 254 | 2046 | 32766 |
| Number of fractions（尾数数量） | 2^2 | 2^3 | 2^10 | 2^7 | 2^23 | 2^52 | 2^112 |
| Number of values（可表示数值数量） | 2^8−4 | 2^8−4 | 1.98×2^15 | 1.98×2^15 | 1.98×2^31 | 1.99×2^63 | 1.99×2^128 |
| Smallest positive normal number（最小正正规数） | 2^-14 | 2^-6 | 2^-14 | 2^-126 | 2^-126 | 2^-1022 | 2^-16382 |
| Largest positive normal number（最大正正规数） | 2^16−2^13 = 2^13(2^3−1)=7.5×2^13 | 2^8−2^4 = 2^4(2^4−1)=15×2^4 | 2^16−2^4 | 2^128−2^104 | 2^128−2^104 | 2^1024−2^971 | 2^16384−2^16271 |
| Smallest subnormal magnitude（最小次正规数大小） | 2^-16 | 2^-9 | 2^-24 | 2^-133 | 2^-149 | 2^-1074 | 2^-16494 |

**重要说明**：

1. **Trailing significand width** 不包含隐含位和符号位
2. **最大正正规数通用计算公式**：
   $$
   (2 - 2^{-t}) \times 2^{E}
   $$
   其中：
   - t = 尾数位数
   - Emax = 最大指数值

### 2.1.3 特殊编码规则

IEEE 754标准定义了三种特殊的数值类型：

- **指数位全 0**：
  - 若尾数位全 0 → 数值为 ±0
  - 若尾数位不全 0 → **subnormal number（次正规数）**
- **指数位全 1**：
  - 若尾数位全 0 → ±∞
  - 若尾数位不全 0 → NaN
- **其他情况**：**normal number（正规数）**

## 2.2 在线浮点数转换工具

为了更好地理解浮点数的编码过程，推荐使用这个在线工具：

🔗 **[浮点数转换器](https://flop.evanau.dev/float-converter)**

这个工具可以：
- 输入十进制数，查看其IEEE 754二进制表示
- 输入二进制位模式，查看对应的十进制值
- 直观展示符号位、指数位、尾数位的含义
- 支持多种浮点格式（float32、float64等）
- 实时计算和验证浮点数的编码

**使用建议**：
1. 尝试输入不同的数值（如0.1、1.0、-3.14等）
2. 观察二进制位模式的变化规律
3. 验证我们下面要学习的解码步骤
4. 理解浮点数的精度限制

## 2.3 浮点数编码

### 2.3.1 十进制到二进制的转换逻辑

将十进制浮点数转换为二进制是浮点数编码的第一步。这个过程可以分为整数部分和小数部分两个步骤：

**整数部分转换**：使用**除2取余法**

1. 将整数除以2，记录余数（0或1）
2. 对商继续除以2，直到商为0
3. 从下往上读取所有余数，即为二进制表示

**示例**：将10转换为二进制

| 除法 | 商 | 余数 |
|------|----|----- |
| 10 ÷ 2 | 5 | 0 |
| 5 ÷ 2 | 2 | 1 |
| 2 ÷ 2 | 1 | 0 |
| 1 ÷ 2 | 0 | 1 |

从下往上读取余数：1010₂

**小数部分转换**：使用**乘2取整法**

1. 将小数乘以2，记录整数部分（0或1）
2. 保留小数部分，继续乘以2
3. 重复上述步骤，直到小数部分为0或达到所需精度
4. 从上往下读取所有整数部分，即为二进制表示

**示例**：将0.625转换为二进制

| 乘法 | 结果 | 整数部分 |
|------|----|----- |
| 0.625 × 2 | 1.25 | 1 |
| 0.25 × 2 | 0.5 | 0 |
| 0.5 × 2 | 1.0 | 1 |

从上往下读取整数部分：0.101₂

**科学记数法表示**：

将二进制转换为科学记数法形式（1.xxx × 2^n）是浮点数编码的关键步骤：

1. 将二进制小数点移动，使得小数点左侧只有一个"1"
2. 记录小数点移动的位数和方向（右移为正，左移为负）

**示例**：10.625₁₀ = 1010.101₂ = 1.010101 × 2^3

**精确表示与舍入**：

重要的是，**并非所有十进制数都能在二进制中精确表示**。例如：

- 0.1₁₀ 在二进制中是无限循环小数：0.0001100110011...₂
- 这导致了浮点数计算中的精度问题

在有限位数的表示中，需要进行舍入，IEEE 754默认使用"向最接近的偶数舍入"规则。

### 2.3.2 编码过程

将十进制数转换为浮点数编码需要以下步骤：

1. **将十进制数转换为二进制**（使用上述方法）
2. **转换为科学记数法**（1.xxx * 2^n 格式）
3. **提取各个部分**：
   - 符号位：正数为0，负数为1
   - 指数：加上偏移量（bias）
   - 尾数：小数部分（隐含位1不存储）
4. **按位模式排列**：符号位 + 指数位 + 尾数位

### 2.3.3 深入float32 (Binary32)

IEEE-754 Binary32（单精度）位示意图：

| 位序号 | 31        | 30 … 23 | 22 … 0         |
|--------|-----------|---------|----------------|
| 字段   | **符号位** | **指数位**（8 bit） | **尾数位**（23 bit） |
| 示例值 | 0         | 01111100 | 01000000000000000000000 |

**解码示例**：`0 01111100 01000000000000000000000₂`

1. **符号位** = 0 → 正数
2. **指数位** = 01111100₂ = 124₁₀ → 指数值 = 124 − 127 = −3
3. **尾数位** = 010…0₂ → 1 + 2⁻² = 1.25
4. **最终数值**：0.15625 = (-1)^0 × 1.25 × 2^{-3}

**验证**：1.25 × 2⁻³ = 1.25 × 0.125 = 0.15625

**💡 提示**：使用[浮点数转换器](https://flop.evanau.dev/float-converter)输入0.15625，验证二进制位模式是否匹配。

### 2.3.4 深入fp8e4m3

fp8e4m3是一种8位浮点格式，适合在资源受限的环境中使用。

| 位序号 | 7         | 6 … 3    | 2 … 0      |
|--------|-----------|----------|------------|
| 字段   | 符号位    | 指数位(4 bit) | 尾数位(3 bit) |
| 示例值 | 0         | 0100     | 010        |

**解码示例**：`0 0100 010`

1. **符号位** = 0 → 正数
2. **指数位** = 0100₂ = 4 → 指数值 = 4 − 7 = −3
3. **尾数位** = 010₂ → 尾数 = 1 + 2⁻² = 1.25
4. **最终数值**：0.15625 = (-1)^0 × 1.25 × 2^-3

**注意**：fp8e4m3与float32在这个例子中表示相同的值，但精度和范围不同。

**💡 提示**：使用[浮点数转换器](https://flop.evanau.dev/float-converter)输入0.15625，对比float32和fp8e4m3的表示差异。

## 2.4 浮点数的特点

### 2.4.1 表示范围 vs 精度

浮点数的一个重要特性是**表示范围与精度的权衡**：

- **高精度格式**（如Binary128）：精度高，但存储空间大
- **低精度格式**（如fp8e4m3）：存储空间小，但精度低
- **中等精度格式**（如Binary32）：平衡精度和存储空间

### 2.4.2 密度分布

浮点数在数轴上的分布是不均匀的：

```
0             0.1         0.5      1     2     4     8     16
|-------------|-----------|--------|-----|-----|-----|-----|
      密集         较密集      中等    中等   稀疏   稀疏  稀疏
```

- 接近0的区域：数值密集，精度高
- 远离0的区域：数值稀疏，精度低

### 2.4.3 特殊值处理

IEEE 754标准定义了多种特殊值：

- **±0**：表示正负零
- **±∞**：表示无穷大
- **NaN**：表示"非数字"
- **次正规数**：填补0和最小正规数之间的空隙

## 2.5 实际应用考虑

### 2.5.1 精度选择

选择合适的浮点格式需要考虑：

1. **应用需求**：需要多少位精度？
2. **存储限制**：可用存储空间是多少？
3. **性能要求**：运算速度要求如何？
4. **兼容性**：是否需要与其他系统兼容？

### 2.5.2 常见选择

- **科学计算**：Binary64（double）
- **图形渲染**：Binary32（float）
- **机器学习**：float16或bfloat16
- **嵌入式系统**：fp8e4m3等自定义格式

## 2.6 小结

浮点数相比整数引入了：

1. **复杂性**：需要理解指数、尾数、偏移量等概念
2. **灵活性**：可以表示非常大和非常小的数
3. **权衡**：精度与范围的权衡
4. **标准化**：IEEE 754标准确保跨平台兼容性

**实践建议**：
- 使用[浮点数转换器](https://flop.evanau.dev/float-converter)进行交互式学习
- 尝试不同的数值，观察二进制编码的变化
- 对比不同精度格式的表示差异
- 验证理论计算与实际编码的一致性

在下一章中，我们将深入探讨浮点数计算中的误差问题，理解为什么浮点数不能像整数那样"乖乖听话"。

---

**下一章**：[浮点数计算误差](./03-浮点数计算误差.md)