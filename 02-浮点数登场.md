# 2 浮点数登场

在理解了整数的精确性和可靠性之后，我们现在要面对一个更复杂的世界：浮点数。浮点数打破了整数的"规则"，引入了新的挑战和可能性。

## 2.1 IEEE 754 定义的浮点数

### 2.1.1 基本公式

IEEE 754标准定义的浮点数表示公式：

$$
value = (-1)^s × (1 + Σ frac[i]·2^{-(i+1)}) × 2^{(exp - bias)}
$$

其中：
- **s**: 符号位 (0=正数, 1=负数)
- **frac[i]**: 尾数位的第i位
- **exp**: 指数位的值
- **bias**: 指数偏移量

### 2.1.2 各种精度格式对比

**Table 10.3 Extended IEEE 754 Format Parameters**

| Parameter | fp8e5m2 | fp8e4m3 | float16 | bfloat16 | Binary32 | Binary64 | Binary128 |
|---|---|---|---|---|---|---|---|
| Storage width (bits)（存储宽度，位数） | 8 | 8 | 16 | 16 | 32 | 64 | 128 |
| Exponent width (bits)（指数宽度，位数） | 5 | 4 | 5 | 8 | 8 | 11 | 15 |
| Exponent bias（指数偏移量） | 15 | 7 | 15 | 127 | 127 | 1023 | 16383 |
| Maximum exponent（最大指数） | 15 | 7 | 15 | 127 | 127 | 1023 | 16383 |
| Minimum exponent（最小指数） | -14 | -6 | -14 | -126 | -126 | -1022 | -16382 |
| Approx normal number range (base 10)（近似正规数范围（以10为底）） | ~10^-4.5 – 10^4.5 | ~10^-2.4 – 10^2.4 | ~10^-4.8 – 10^4.8 | ~10^-38 – 10^38 | 10^-38 – 10^+38 | 10^-308 – 10^+308 | 10^-4932 – 10^+4932 |
| Trailing significand width (bits)*（尾数部分宽度，位数）* | 2 | 3 | 10 | 7 | 23 | 52 | 112 |
| Number of exponents（指数数量） | 30 | 14 | 30 | 254 | 254 | 2046 | 32766 |
| Number of fractions（尾数数量） | 2^2 | 2^3 | 2^10 | 2^7 | 2^23 | 2^52 | 2^112 |
| Number of values（可表示数值数量） | 2^8−4 | 2^8−4 | 1.98×2^15 | 1.98×2^15 | 1.98×2^31 | 1.99×2^63 | 1.99×2^128 |
| Smallest positive normal number（最小正正规数） | 2^-14 | 2^-6 | 2^-14 | 2^-126 | 2^-126 | 2^-1022 | 2^-16382 |
| Largest positive normal number（最大正正规数） | 2^16−2^13 = 2^13(2^3−1)=7.5×2^13 | 2^8−2^4 = 2^4(2^4−1)=15×2^4 | 2^16−2^4 | 2^128−2^104 | 2^128−2^104 | 2^1024−2^971 | 2^16384−2^16271 |
| Smallest subnormal magnitude（最小次正规数大小） | 2^-16 | 2^-9 | 2^-24 | 2^-133 | 2^-149 | 2^-1074 | 2^-16494 |

**重要说明**：

1. **Trailing significand width** 不包含隐含位和符号位
2. **最大正正规数通用计算公式**：
   $$
   (2 - 2^{-t}) \times 2^{E}
   $$
   其中：
   - t = 尾数位数
   - Emax = 最大指数值

### 2.1.3 特殊编码规则

IEEE 754标准定义了三种特殊的数值类型：

#### 2.1.3.1 指数位全 0
- **若尾数位全 0** → 数值为 ±0
- **若尾数位不全 0** → **subnormal number（次正规数）**

#### 2.1.3.2 指数位全 1
- **若尾数位全 0** → ±∞
- **若尾数位不全 0** → NaN

#### 2.1.3.3 其他情况
- **normal number（正规数）**

## 2.2 深入理解各种格式

### 2.2.1 在线浮点数转换工具

为了更好地理解浮点数的编码过程，推荐使用这个在线工具：

🔗 **[浮点数转换器](https://flop.evanau.dev/float-converter)**

这个工具可以：
- 输入十进制数，查看其IEEE 754二进制表示
- 输入二进制位模式，查看对应的十进制值
- 直观展示符号位、指数位、尾数位的含义
- 支持多种浮点格式（float32、float64等）
- 实时计算和验证浮点数的编码

**使用建议**：
1. 尝试输入不同的数值（如0.1、1.0、-3.14等）
2. 观察二进制位模式的变化规律
3. 验证我们下面要学习的解码步骤
4. 理解浮点数的精度限制

### 2.2.2 深入float32 (Binary32)

IEEE-754 Binary32（单精度）位示意图：

| 位序号 | 31        | 30 … 23 | 22 … 0         |
|--------|-----------|---------|----------------|
| 字段   | **符号位** | **指数位**（8 bit） | **尾数位**（23 bit） |
| 示例值 | 0         | 01111100 | 01000000000000000000000 |

#### 2.2.1.1 解码步骤

以示例值 `0 01111100 01000000000000000000000` 为例：

1. **符号位** = 0 → 正数
2. **指数位** = 01111100₂ = 124₁₀
   - 指数值 = 124 − 127 = −3
3. **尾数位** = 010…0₂ → 1 + 2⁻² = 1.25

**💡 验证建议**：使用[浮点数转换器](https://flop.evanau.dev/float-converter)输入0.15625，验证二进制位模式是否匹配。

#### 2.2.1.2 最终数值

```math
0.15625 = (-1)^0 \times 1.25 \times 2^{-3}
```

**验证**：1.25 × 2⁻³ = 1.25 × 0.125 = 0.15625

### 2.2.3 深入fp8e4m3

fp8e4m3是一种8位浮点格式，适合在资源受限的环境中使用。

| 位序号 | 7         | 6 … 3    | 2 … 0      |
|--------|-----------|----------|------------|
| 字段   | 符号位    | 指数位(4 bit) | 尾数位(3 bit) |
| 示例值 | 0         | 0100     | 010        |

#### 2.2.2.1 解码步骤

以示例值 `0 0100 010` 为例：

1. **符号位** = 0 → 正数
2. **指数位** = 0100₂ = 4 → 指数值 = 4 − 7 = −3
3. **尾数位** = 010₂ → 尾数 = 1 + 2⁻² = 1.25

**💡 验证建议**：使用[浮点数转换器](https://flop.evanau.dev/float-converter)输入0.15625，对比float32和fp8e4m3的表示差异。

#### 2.2.2.2 最终数值

```
0.15625 = (-1)^0 * 1.25 * 2^-3
```

**注意**：fp8e4m3与float32在这个例子中表示相同的值，但精度和范围不同。

## 2.3 浮点数的特点

### 2.3.1 表示范围 vs 精度

浮点数的一个重要特性是**表示范围与精度的权衡**：

- **高精度格式**（如Binary128）：精度高，但存储空间大
- **低精度格式**（如fp8e4m3）：存储空间小，但精度低
- **中等精度格式**（如Binary32）：平衡精度和存储空间

### 2.3.2 密度分布

浮点数在数轴上的分布是不均匀的：

```
0             0.1         0.5      1     2     4     8     16
|-------------|-----------|--------|-----|-----|-----|-----|
      密集         较密集      中等    中等   稀疏   稀疏  稀疏
```

- 接近0的区域：数值密集，精度高
- 远离0的区域：数值稀疏，精度低

### 2.3.3 特殊值处理

IEEE 754标准定义了多种特殊值：

- **±0**：表示正负零
- **±∞**：表示无穷大
- **NaN**：表示"非数字"
- **次正规数**：填补0和最小正规数之间的空隙

## 2.4 实际应用考虑

### 2.4.1 精度选择

选择合适的浮点格式需要考虑：

1. **应用需求**：需要多少位精度？
2. **存储限制**：可用存储空间是多少？
3. **性能要求**：运算速度要求如何？
4. **兼容性**：是否需要与其他系统兼容？

### 2.4.2 常见选择

- **科学计算**：Binary64（double）
- **图形渲染**：Binary32（float）
- **机器学习**：float16或bfloat16
- **嵌入式系统**：fp8e4m3等自定义格式

## 2.5 小结

浮点数相比整数引入了：

1. **复杂性**：需要理解指数、尾数、偏移量等概念
2. **灵活性**：可以表示非常大和非常小的数
3. **权衡**：精度与范围的权衡
4. **标准化**：IEEE 754标准确保跨平台兼容性

**实践建议**：
- 使用[浮点数转换器](https://flop.evanau.dev/float-converter)进行交互式学习
- 尝试不同的数值，观察二进制编码的变化
- 对比不同精度格式的表示差异
- 验证理论计算与实际编码的一致性

在下一章中，我们将深入探讨浮点数计算中的误差问题，理解为什么浮点数不能像整数那样"乖乖听话"。

---

**下一章**：[浮点数计算误差](./03-浮点数计算误差.md)
